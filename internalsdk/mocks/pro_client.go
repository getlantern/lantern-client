// Code generated by mockery v2.49.1. DO NOT EDIT.

package mocks

import (
	context "context"

	pro "github.com/getlantern/lantern-client/internalsdk/pro"
	mock "github.com/stretchr/testify/mock"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"

	protos "github.com/getlantern/lantern-client/internalsdk/protos"

	time "time"
)

// ProClient is an autogenerated mock type for the ProClient type
type ProClient struct {
	mock.Mock
}

type ProClient_Expecter struct {
	mock *mock.Mock
}

func (_m *ProClient) EXPECT() *ProClient_Expecter {
	return &ProClient_Expecter{mock: &_m.Mock}
}

// DeviceAdd provides a mock function with given fields: ctx, deviceName
func (_m *ProClient) DeviceAdd(ctx context.Context, deviceName string) (bool, error) {
	ret := _m.Called(ctx, deviceName)

	if len(ret) == 0 {
		panic("no return value specified for DeviceAdd")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, deviceName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, deviceName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, deviceName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_DeviceAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeviceAdd'
type ProClient_DeviceAdd_Call struct {
	*mock.Call
}

// DeviceAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - deviceName string
func (_e *ProClient_Expecter) DeviceAdd(ctx interface{}, deviceName interface{}) *ProClient_DeviceAdd_Call {
	return &ProClient_DeviceAdd_Call{Call: _e.mock.On("DeviceAdd", ctx, deviceName)}
}

func (_c *ProClient_DeviceAdd_Call) Run(run func(ctx context.Context, deviceName string)) *ProClient_DeviceAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_DeviceAdd_Call) Return(_a0 bool, _a1 error) *ProClient_DeviceAdd_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_DeviceAdd_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *ProClient_DeviceAdd_Call {
	_c.Call.Return(run)
	return _c
}

// DeviceRemove provides a mock function with given fields: ctx, deviceId
func (_m *ProClient) DeviceRemove(ctx context.Context, deviceId string) (*pro.LinkResponse, error) {
	ret := _m.Called(ctx, deviceId)

	if len(ret) == 0 {
		panic("no return value specified for DeviceRemove")
	}

	var r0 *pro.LinkResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*pro.LinkResponse, error)); ok {
		return rf(ctx, deviceId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *pro.LinkResponse); ok {
		r0 = rf(ctx, deviceId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.LinkResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, deviceId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_DeviceRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeviceRemove'
type ProClient_DeviceRemove_Call struct {
	*mock.Call
}

// DeviceRemove is a helper method to define mock.On call
//   - ctx context.Context
//   - deviceId string
func (_e *ProClient_Expecter) DeviceRemove(ctx interface{}, deviceId interface{}) *ProClient_DeviceRemove_Call {
	return &ProClient_DeviceRemove_Call{Call: _e.mock.On("DeviceRemove", ctx, deviceId)}
}

func (_c *ProClient_DeviceRemove_Call) Run(run func(ctx context.Context, deviceId string)) *ProClient_DeviceRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_DeviceRemove_Call) Return(_a0 *pro.LinkResponse, _a1 error) *ProClient_DeviceRemove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_DeviceRemove_Call) RunAndReturn(run func(context.Context, string) (*pro.LinkResponse, error)) *ProClient_DeviceRemove_Call {
	_c.Call.Return(run)
	return _c
}

// EmailExists provides a mock function with given fields: ctx, email
func (_m *ProClient) EmailExists(ctx context.Context, email string) (*protos.BaseResponse, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for EmailExists")
	}

	var r0 *protos.BaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*protos.BaseResponse, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *protos.BaseResponse); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protos.BaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_EmailExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EmailExists'
type ProClient_EmailExists_Call struct {
	*mock.Call
}

// EmailExists is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *ProClient_Expecter) EmailExists(ctx interface{}, email interface{}) *ProClient_EmailExists_Call {
	return &ProClient_EmailExists_Call{Call: _e.mock.On("EmailExists", ctx, email)}
}

func (_c *ProClient_EmailExists_Call) Run(run func(ctx context.Context, email string)) *ProClient_EmailExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_EmailExists_Call) Return(_a0 *protos.BaseResponse, _a1 error) *ProClient_EmailExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_EmailExists_Call) RunAndReturn(run func(context.Context, string) (*protos.BaseResponse, error)) *ProClient_EmailExists_Call {
	_c.Call.Return(run)
	return _c
}

// EmailRequest provides a mock function with given fields: ctx, email
func (_m *ProClient) EmailRequest(ctx context.Context, email string) (*pro.OkResponse, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for EmailRequest")
	}

	var r0 *pro.OkResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*pro.OkResponse, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *pro.OkResponse); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.OkResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_EmailRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EmailRequest'
type ProClient_EmailRequest_Call struct {
	*mock.Call
}

// EmailRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *ProClient_Expecter) EmailRequest(ctx interface{}, email interface{}) *ProClient_EmailRequest_Call {
	return &ProClient_EmailRequest_Call{Call: _e.mock.On("EmailRequest", ctx, email)}
}

func (_c *ProClient_EmailRequest_Call) Run(run func(ctx context.Context, email string)) *ProClient_EmailRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_EmailRequest_Call) Return(_a0 *pro.OkResponse, _a1 error) *ProClient_EmailRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_EmailRequest_Call) RunAndReturn(run func(context.Context, string) (*pro.OkResponse, error)) *ProClient_EmailRequest_Call {
	_c.Call.Return(run)
	return _c
}

// GetJSON provides a mock function with given fields: ctx, path, params, target
func (_m *ProClient) GetJSON(ctx context.Context, path string, params interface{}, target interface{}) error {
	ret := _m.Called(ctx, path, params, target)

	if len(ret) == 0 {
		panic("no return value specified for GetJSON")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) error); ok {
		r0 = rf(ctx, path, params, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProClient_GetJSON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJSON'
type ProClient_GetJSON_Call struct {
	*mock.Call
}

// GetJSON is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - params any
//   - target any
func (_e *ProClient_Expecter) GetJSON(ctx interface{}, path interface{}, params interface{}, target interface{}) *ProClient_GetJSON_Call {
	return &ProClient_GetJSON_Call{Call: _e.mock.On("GetJSON", ctx, path, params, target)}
}

func (_c *ProClient_GetJSON_Call) Run(run func(ctx context.Context, path string, params any, target any)) *ProClient_GetJSON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(any), args[3].(any))
	})
	return _c
}

func (_c *ProClient_GetJSON_Call) Return(_a0 error) *ProClient_GetJSON_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ProClient_GetJSON_Call) RunAndReturn(run func(context.Context, string, any, any) error) *ProClient_GetJSON_Call {
	_c.Call.Return(run)
	return _c
}

// GetPROTOC provides a mock function with given fields: ctx, path, params, target
func (_m *ProClient) GetPROTOC(ctx context.Context, path string, params interface{}, target protoreflect.ProtoMessage) error {
	ret := _m.Called(ctx, path, params, target)

	if len(ret) == 0 {
		panic("no return value specified for GetPROTOC")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, protoreflect.ProtoMessage) error); ok {
		r0 = rf(ctx, path, params, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProClient_GetPROTOC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPROTOC'
type ProClient_GetPROTOC_Call struct {
	*mock.Call
}

// GetPROTOC is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - params any
//   - target protoreflect.ProtoMessage
func (_e *ProClient_Expecter) GetPROTOC(ctx interface{}, path interface{}, params interface{}, target interface{}) *ProClient_GetPROTOC_Call {
	return &ProClient_GetPROTOC_Call{Call: _e.mock.On("GetPROTOC", ctx, path, params, target)}
}

func (_c *ProClient_GetPROTOC_Call) Run(run func(ctx context.Context, path string, params any, target protoreflect.ProtoMessage)) *ProClient_GetPROTOC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(any), args[3].(protoreflect.ProtoMessage))
	})
	return _c
}

func (_c *ProClient_GetPROTOC_Call) Return(_a0 error) *ProClient_GetPROTOC_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ProClient_GetPROTOC_Call) RunAndReturn(run func(context.Context, string, any, protoreflect.ProtoMessage) error) *ProClient_GetPROTOC_Call {
	_c.Call.Return(run)
	return _c
}

// LinkCodeApprove provides a mock function with given fields: ctx, code
func (_m *ProClient) LinkCodeApprove(ctx context.Context, code string) (*protos.BaseResponse, error) {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for LinkCodeApprove")
	}

	var r0 *protos.BaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*protos.BaseResponse, error)); ok {
		return rf(ctx, code)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *protos.BaseResponse); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protos.BaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, code)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_LinkCodeApprove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkCodeApprove'
type ProClient_LinkCodeApprove_Call struct {
	*mock.Call
}

// LinkCodeApprove is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *ProClient_Expecter) LinkCodeApprove(ctx interface{}, code interface{}) *ProClient_LinkCodeApprove_Call {
	return &ProClient_LinkCodeApprove_Call{Call: _e.mock.On("LinkCodeApprove", ctx, code)}
}

func (_c *ProClient_LinkCodeApprove_Call) Run(run func(ctx context.Context, code string)) *ProClient_LinkCodeApprove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_LinkCodeApprove_Call) Return(_a0 *protos.BaseResponse, _a1 error) *ProClient_LinkCodeApprove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_LinkCodeApprove_Call) RunAndReturn(run func(context.Context, string) (*protos.BaseResponse, error)) *ProClient_LinkCodeApprove_Call {
	_c.Call.Return(run)
	return _c
}

// LinkCodeRedeem provides a mock function with given fields: ctx, deviceName, deviceCode
func (_m *ProClient) LinkCodeRedeem(ctx context.Context, deviceName string, deviceCode string) (*pro.LinkCodeRedeemResponse, error) {
	ret := _m.Called(ctx, deviceName, deviceCode)

	if len(ret) == 0 {
		panic("no return value specified for LinkCodeRedeem")
	}

	var r0 *pro.LinkCodeRedeemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*pro.LinkCodeRedeemResponse, error)); ok {
		return rf(ctx, deviceName, deviceCode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *pro.LinkCodeRedeemResponse); ok {
		r0 = rf(ctx, deviceName, deviceCode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.LinkCodeRedeemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, deviceName, deviceCode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_LinkCodeRedeem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkCodeRedeem'
type ProClient_LinkCodeRedeem_Call struct {
	*mock.Call
}

// LinkCodeRedeem is a helper method to define mock.On call
//   - ctx context.Context
//   - deviceName string
//   - deviceCode string
func (_e *ProClient_Expecter) LinkCodeRedeem(ctx interface{}, deviceName interface{}, deviceCode interface{}) *ProClient_LinkCodeRedeem_Call {
	return &ProClient_LinkCodeRedeem_Call{Call: _e.mock.On("LinkCodeRedeem", ctx, deviceName, deviceCode)}
}

func (_c *ProClient_LinkCodeRedeem_Call) Run(run func(ctx context.Context, deviceName string, deviceCode string)) *ProClient_LinkCodeRedeem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *ProClient_LinkCodeRedeem_Call) Return(_a0 *pro.LinkCodeRedeemResponse, _a1 error) *ProClient_LinkCodeRedeem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_LinkCodeRedeem_Call) RunAndReturn(run func(context.Context, string, string) (*pro.LinkCodeRedeemResponse, error)) *ProClient_LinkCodeRedeem_Call {
	_c.Call.Return(run)
	return _c
}

// LinkCodeRequest provides a mock function with given fields: ctx, deviceName
func (_m *ProClient) LinkCodeRequest(ctx context.Context, deviceName string) (*pro.LinkCodeResponse, error) {
	ret := _m.Called(ctx, deviceName)

	if len(ret) == 0 {
		panic("no return value specified for LinkCodeRequest")
	}

	var r0 *pro.LinkCodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*pro.LinkCodeResponse, error)); ok {
		return rf(ctx, deviceName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *pro.LinkCodeResponse); ok {
		r0 = rf(ctx, deviceName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.LinkCodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, deviceName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_LinkCodeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkCodeRequest'
type ProClient_LinkCodeRequest_Call struct {
	*mock.Call
}

// LinkCodeRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - deviceName string
func (_e *ProClient_Expecter) LinkCodeRequest(ctx interface{}, deviceName interface{}) *ProClient_LinkCodeRequest_Call {
	return &ProClient_LinkCodeRequest_Call{Call: _e.mock.On("LinkCodeRequest", ctx, deviceName)}
}

func (_c *ProClient_LinkCodeRequest_Call) Run(run func(ctx context.Context, deviceName string)) *ProClient_LinkCodeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_LinkCodeRequest_Call) Return(_a0 *pro.LinkCodeResponse, _a1 error) *ProClient_LinkCodeRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_LinkCodeRequest_Call) RunAndReturn(run func(context.Context, string) (*pro.LinkCodeResponse, error)) *ProClient_LinkCodeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// PaymentMethods provides a mock function with given fields: ctx
func (_m *ProClient) PaymentMethods(ctx context.Context) (*pro.PaymentMethodsResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PaymentMethods")
	}

	var r0 *pro.PaymentMethodsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*pro.PaymentMethodsResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *pro.PaymentMethodsResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.PaymentMethodsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_PaymentMethods_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaymentMethods'
type ProClient_PaymentMethods_Call struct {
	*mock.Call
}

// PaymentMethods is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ProClient_Expecter) PaymentMethods(ctx interface{}) *ProClient_PaymentMethods_Call {
	return &ProClient_PaymentMethods_Call{Call: _e.mock.On("PaymentMethods", ctx)}
}

func (_c *ProClient_PaymentMethods_Call) Run(run func(ctx context.Context)) *ProClient_PaymentMethods_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProClient_PaymentMethods_Call) Return(_a0 *pro.PaymentMethodsResponse, _a1 error) *ProClient_PaymentMethods_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_PaymentMethods_Call) RunAndReturn(run func(context.Context) (*pro.PaymentMethodsResponse, error)) *ProClient_PaymentMethods_Call {
	_c.Call.Return(run)
	return _c
}

// PaymentMethodsV4 provides a mock function with given fields: ctx
func (_m *ProClient) PaymentMethodsV4(ctx context.Context) (*pro.PaymentMethodsResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PaymentMethodsV4")
	}

	var r0 *pro.PaymentMethodsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*pro.PaymentMethodsResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *pro.PaymentMethodsResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.PaymentMethodsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_PaymentMethodsV4_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaymentMethodsV4'
type ProClient_PaymentMethodsV4_Call struct {
	*mock.Call
}

// PaymentMethodsV4 is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ProClient_Expecter) PaymentMethodsV4(ctx interface{}) *ProClient_PaymentMethodsV4_Call {
	return &ProClient_PaymentMethodsV4_Call{Call: _e.mock.On("PaymentMethodsV4", ctx)}
}

func (_c *ProClient_PaymentMethodsV4_Call) Run(run func(ctx context.Context)) *ProClient_PaymentMethodsV4_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProClient_PaymentMethodsV4_Call) Return(_a0 *pro.PaymentMethodsResponse, _a1 error) *ProClient_PaymentMethodsV4_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_PaymentMethodsV4_Call) RunAndReturn(run func(context.Context) (*pro.PaymentMethodsResponse, error)) *ProClient_PaymentMethodsV4_Call {
	_c.Call.Return(run)
	return _c
}

// PaymentRedirect provides a mock function with given fields: ctx, req
func (_m *ProClient) PaymentRedirect(ctx context.Context, req *protos.PaymentRedirectRequest) (*pro.PaymentRedirectResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for PaymentRedirect")
	}

	var r0 *pro.PaymentRedirectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *protos.PaymentRedirectRequest) (*pro.PaymentRedirectResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *protos.PaymentRedirectRequest) *pro.PaymentRedirectResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.PaymentRedirectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *protos.PaymentRedirectRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_PaymentRedirect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaymentRedirect'
type ProClient_PaymentRedirect_Call struct {
	*mock.Call
}

// PaymentRedirect is a helper method to define mock.On call
//   - ctx context.Context
//   - req *protos.PaymentRedirectRequest
func (_e *ProClient_Expecter) PaymentRedirect(ctx interface{}, req interface{}) *ProClient_PaymentRedirect_Call {
	return &ProClient_PaymentRedirect_Call{Call: _e.mock.On("PaymentRedirect", ctx, req)}
}

func (_c *ProClient_PaymentRedirect_Call) Run(run func(ctx context.Context, req *protos.PaymentRedirectRequest)) *ProClient_PaymentRedirect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*protos.PaymentRedirectRequest))
	})
	return _c
}

func (_c *ProClient_PaymentRedirect_Call) Return(_a0 *pro.PaymentRedirectResponse, _a1 error) *ProClient_PaymentRedirect_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_PaymentRedirect_Call) RunAndReturn(run func(context.Context, *protos.PaymentRedirectRequest) (*pro.PaymentRedirectResponse, error)) *ProClient_PaymentRedirect_Call {
	_c.Call.Return(run)
	return _c
}

// Plans provides a mock function with given fields: ctx
func (_m *ProClient) Plans(ctx context.Context) (*pro.PlansResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Plans")
	}

	var r0 *pro.PlansResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*pro.PlansResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *pro.PlansResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.PlansResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_Plans_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Plans'
type ProClient_Plans_Call struct {
	*mock.Call
}

// Plans is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ProClient_Expecter) Plans(ctx interface{}) *ProClient_Plans_Call {
	return &ProClient_Plans_Call{Call: _e.mock.On("Plans", ctx)}
}

func (_c *ProClient_Plans_Call) Run(run func(ctx context.Context)) *ProClient_Plans_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProClient_Plans_Call) Return(_a0 *pro.PlansResponse, _a1 error) *ProClient_Plans_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_Plans_Call) RunAndReturn(run func(context.Context) (*pro.PlansResponse, error)) *ProClient_Plans_Call {
	_c.Call.Return(run)
	return _c
}

// PollUserData provides a mock function with given fields: ctx, session, maxElapsedTime
func (_m *ProClient) PollUserData(ctx context.Context, session pro.ClientSession, maxElapsedTime time.Duration) {
	_m.Called(ctx, session, maxElapsedTime)
}

// ProClient_PollUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PollUserData'
type ProClient_PollUserData_Call struct {
	*mock.Call
}

// PollUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - session pro.ClientSession
//   - maxElapsedTime time.Duration
func (_e *ProClient_Expecter) PollUserData(ctx interface{}, session interface{}, maxElapsedTime interface{}) *ProClient_PollUserData_Call {
	return &ProClient_PollUserData_Call{Call: _e.mock.On("PollUserData", ctx, session, maxElapsedTime)}
}

func (_c *ProClient_PollUserData_Call) Run(run func(ctx context.Context, session pro.ClientSession, maxElapsedTime time.Duration)) *ProClient_PollUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pro.ClientSession), args[2].(time.Duration))
	})
	return _c
}

func (_c *ProClient_PollUserData_Call) Return() *ProClient_PollUserData_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProClient_PollUserData_Call) RunAndReturn(run func(context.Context, pro.ClientSession, time.Duration)) *ProClient_PollUserData_Call {
	_c.Call.Return(run)
	return _c
}

// PostFormReadingJSON provides a mock function with given fields: ctx, path, params, target
func (_m *ProClient) PostFormReadingJSON(ctx context.Context, path string, params interface{}, target interface{}) error {
	ret := _m.Called(ctx, path, params, target)

	if len(ret) == 0 {
		panic("no return value specified for PostFormReadingJSON")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) error); ok {
		r0 = rf(ctx, path, params, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProClient_PostFormReadingJSON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostFormReadingJSON'
type ProClient_PostFormReadingJSON_Call struct {
	*mock.Call
}

// PostFormReadingJSON is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - params any
//   - target any
func (_e *ProClient_Expecter) PostFormReadingJSON(ctx interface{}, path interface{}, params interface{}, target interface{}) *ProClient_PostFormReadingJSON_Call {
	return &ProClient_PostFormReadingJSON_Call{Call: _e.mock.On("PostFormReadingJSON", ctx, path, params, target)}
}

func (_c *ProClient_PostFormReadingJSON_Call) Run(run func(ctx context.Context, path string, params any, target any)) *ProClient_PostFormReadingJSON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(any), args[3].(any))
	})
	return _c
}

func (_c *ProClient_PostFormReadingJSON_Call) Return(_a0 error) *ProClient_PostFormReadingJSON_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ProClient_PostFormReadingJSON_Call) RunAndReturn(run func(context.Context, string, any, any) error) *ProClient_PostFormReadingJSON_Call {
	_c.Call.Return(run)
	return _c
}

// PostJSONReadingJSON provides a mock function with given fields: ctx, path, params, body, target
func (_m *ProClient) PostJSONReadingJSON(ctx context.Context, path string, params interface{}, body interface{}, target interface{}) error {
	ret := _m.Called(ctx, path, params, body, target)

	if len(ret) == 0 {
		panic("no return value specified for PostJSONReadingJSON")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}, interface{}) error); ok {
		r0 = rf(ctx, path, params, body, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProClient_PostJSONReadingJSON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostJSONReadingJSON'
type ProClient_PostJSONReadingJSON_Call struct {
	*mock.Call
}

// PostJSONReadingJSON is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - params any
//   - body any
//   - target any
func (_e *ProClient_Expecter) PostJSONReadingJSON(ctx interface{}, path interface{}, params interface{}, body interface{}, target interface{}) *ProClient_PostJSONReadingJSON_Call {
	return &ProClient_PostJSONReadingJSON_Call{Call: _e.mock.On("PostJSONReadingJSON", ctx, path, params, body, target)}
}

func (_c *ProClient_PostJSONReadingJSON_Call) Run(run func(ctx context.Context, path string, params any, body any, target any)) *ProClient_PostJSONReadingJSON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(any), args[3].(any), args[4].(any))
	})
	return _c
}

func (_c *ProClient_PostJSONReadingJSON_Call) Return(_a0 error) *ProClient_PostJSONReadingJSON_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ProClient_PostJSONReadingJSON_Call) RunAndReturn(run func(context.Context, string, any, any, any) error) *ProClient_PostJSONReadingJSON_Call {
	_c.Call.Return(run)
	return _c
}

// PostPROTOC provides a mock function with given fields: ctx, path, params, body, target
func (_m *ProClient) PostPROTOC(ctx context.Context, path string, params protoreflect.ProtoMessage, body protoreflect.ProtoMessage, target protoreflect.ProtoMessage) error {
	ret := _m.Called(ctx, path, params, body, target)

	if len(ret) == 0 {
		panic("no return value specified for PostPROTOC")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, protoreflect.ProtoMessage, protoreflect.ProtoMessage, protoreflect.ProtoMessage) error); ok {
		r0 = rf(ctx, path, params, body, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProClient_PostPROTOC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostPROTOC'
type ProClient_PostPROTOC_Call struct {
	*mock.Call
}

// PostPROTOC is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - params protoreflect.ProtoMessage
//   - body protoreflect.ProtoMessage
//   - target protoreflect.ProtoMessage
func (_e *ProClient_Expecter) PostPROTOC(ctx interface{}, path interface{}, params interface{}, body interface{}, target interface{}) *ProClient_PostPROTOC_Call {
	return &ProClient_PostPROTOC_Call{Call: _e.mock.On("PostPROTOC", ctx, path, params, body, target)}
}

func (_c *ProClient_PostPROTOC_Call) Run(run func(ctx context.Context, path string, params protoreflect.ProtoMessage, body protoreflect.ProtoMessage, target protoreflect.ProtoMessage)) *ProClient_PostPROTOC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(protoreflect.ProtoMessage), args[3].(protoreflect.ProtoMessage), args[4].(protoreflect.ProtoMessage))
	})
	return _c
}

func (_c *ProClient_PostPROTOC_Call) Return(_a0 error) *ProClient_PostPROTOC_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ProClient_PostPROTOC_Call) RunAndReturn(run func(context.Context, string, protoreflect.ProtoMessage, protoreflect.ProtoMessage, protoreflect.ProtoMessage) error) *ProClient_PostPROTOC_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseRequest provides a mock function with given fields: ctx, data
func (_m *ProClient) PurchaseRequest(ctx context.Context, data map[string]interface{}) (*pro.PurchaseResponse, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseRequest")
	}

	var r0 *pro.PurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) (*pro.PurchaseResponse, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) *pro.PurchaseResponse); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.PurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]interface{}) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_PurchaseRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseRequest'
type ProClient_PurchaseRequest_Call struct {
	*mock.Call
}

// PurchaseRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - data map[string]interface{}
func (_e *ProClient_Expecter) PurchaseRequest(ctx interface{}, data interface{}) *ProClient_PurchaseRequest_Call {
	return &ProClient_PurchaseRequest_Call{Call: _e.mock.On("PurchaseRequest", ctx, data)}
}

func (_c *ProClient_PurchaseRequest_Call) Run(run func(ctx context.Context, data map[string]interface{})) *ProClient_PurchaseRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *ProClient_PurchaseRequest_Call) Return(_a0 *pro.PurchaseResponse, _a1 error) *ProClient_PurchaseRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_PurchaseRequest_Call) RunAndReturn(run func(context.Context, map[string]interface{}) (*pro.PurchaseResponse, error)) *ProClient_PurchaseRequest_Call {
	_c.Call.Return(run)
	return _c
}

// RedeemResellerCode provides a mock function with given fields: ctx, req
func (_m *ProClient) RedeemResellerCode(ctx context.Context, req *protos.RedeemResellerCodeRequest) (*protos.BaseResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for RedeemResellerCode")
	}

	var r0 *protos.BaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *protos.RedeemResellerCodeRequest) (*protos.BaseResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *protos.RedeemResellerCodeRequest) *protos.BaseResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protos.BaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *protos.RedeemResellerCodeRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_RedeemResellerCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RedeemResellerCode'
type ProClient_RedeemResellerCode_Call struct {
	*mock.Call
}

// RedeemResellerCode is a helper method to define mock.On call
//   - ctx context.Context
//   - req *protos.RedeemResellerCodeRequest
func (_e *ProClient_Expecter) RedeemResellerCode(ctx interface{}, req interface{}) *ProClient_RedeemResellerCode_Call {
	return &ProClient_RedeemResellerCode_Call{Call: _e.mock.On("RedeemResellerCode", ctx, req)}
}

func (_c *ProClient_RedeemResellerCode_Call) Run(run func(ctx context.Context, req *protos.RedeemResellerCodeRequest)) *ProClient_RedeemResellerCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*protos.RedeemResellerCodeRequest))
	})
	return _c
}

func (_c *ProClient_RedeemResellerCode_Call) Return(_a0 *protos.BaseResponse, _a1 error) *ProClient_RedeemResellerCode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_RedeemResellerCode_Call) RunAndReturn(run func(context.Context, *protos.RedeemResellerCodeRequest) (*protos.BaseResponse, error)) *ProClient_RedeemResellerCode_Call {
	_c.Call.Return(run)
	return _c
}

// ReferralAttach provides a mock function with given fields: ctx, refCode
func (_m *ProClient) ReferralAttach(ctx context.Context, refCode string) (bool, error) {
	ret := _m.Called(ctx, refCode)

	if len(ret) == 0 {
		panic("no return value specified for ReferralAttach")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, refCode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, refCode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, refCode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_ReferralAttach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReferralAttach'
type ProClient_ReferralAttach_Call struct {
	*mock.Call
}

// ReferralAttach is a helper method to define mock.On call
//   - ctx context.Context
//   - refCode string
func (_e *ProClient_Expecter) ReferralAttach(ctx interface{}, refCode interface{}) *ProClient_ReferralAttach_Call {
	return &ProClient_ReferralAttach_Call{Call: _e.mock.On("ReferralAttach", ctx, refCode)}
}

func (_c *ProClient_ReferralAttach_Call) Run(run func(ctx context.Context, refCode string)) *ProClient_ReferralAttach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_ReferralAttach_Call) Return(_a0 bool, _a1 error) *ProClient_ReferralAttach_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_ReferralAttach_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *ProClient_ReferralAttach_Call {
	_c.Call.Return(run)
	return _c
}

// RestorePurchase provides a mock function with given fields: ctx, req
func (_m *ProClient) RestorePurchase(ctx context.Context, req map[string]interface{}) (*pro.OkResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for RestorePurchase")
	}

	var r0 *pro.OkResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) (*pro.OkResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) *pro.OkResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.OkResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]interface{}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_RestorePurchase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestorePurchase'
type ProClient_RestorePurchase_Call struct {
	*mock.Call
}

// RestorePurchase is a helper method to define mock.On call
//   - ctx context.Context
//   - req map[string]interface{}
func (_e *ProClient_Expecter) RestorePurchase(ctx interface{}, req interface{}) *ProClient_RestorePurchase_Call {
	return &ProClient_RestorePurchase_Call{Call: _e.mock.On("RestorePurchase", ctx, req)}
}

func (_c *ProClient_RestorePurchase_Call) Run(run func(ctx context.Context, req map[string]interface{})) *ProClient_RestorePurchase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *ProClient_RestorePurchase_Call) Return(_a0 *pro.OkResponse, _a1 error) *ProClient_RestorePurchase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_RestorePurchase_Call) RunAndReturn(run func(context.Context, map[string]interface{}) (*pro.OkResponse, error)) *ProClient_RestorePurchase_Call {
	_c.Call.Return(run)
	return _c
}

// RetryCreateUser provides a mock function with given fields: ctx, ss, maxElapsedTime
func (_m *ProClient) RetryCreateUser(ctx context.Context, ss pro.ClientSession, maxElapsedTime time.Duration) {
	_m.Called(ctx, ss, maxElapsedTime)
}

// ProClient_RetryCreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryCreateUser'
type ProClient_RetryCreateUser_Call struct {
	*mock.Call
}

// RetryCreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - ss pro.ClientSession
//   - maxElapsedTime time.Duration
func (_e *ProClient_Expecter) RetryCreateUser(ctx interface{}, ss interface{}, maxElapsedTime interface{}) *ProClient_RetryCreateUser_Call {
	return &ProClient_RetryCreateUser_Call{Call: _e.mock.On("RetryCreateUser", ctx, ss, maxElapsedTime)}
}

func (_c *ProClient_RetryCreateUser_Call) Run(run func(ctx context.Context, ss pro.ClientSession, maxElapsedTime time.Duration)) *ProClient_RetryCreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pro.ClientSession), args[2].(time.Duration))
	})
	return _c
}

func (_c *ProClient_RetryCreateUser_Call) Return() *ProClient_RetryCreateUser_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProClient_RetryCreateUser_Call) RunAndReturn(run func(context.Context, pro.ClientSession, time.Duration)) *ProClient_RetryCreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserData provides a mock function with given fields: ctx, ss
func (_m *ProClient) UpdateUserData(ctx context.Context, ss pro.ClientSession) (*protos.User, error) {
	ret := _m.Called(ctx, ss)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserData")
	}

	var r0 *protos.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pro.ClientSession) (*protos.User, error)); ok {
		return rf(ctx, ss)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pro.ClientSession) *protos.User); ok {
		r0 = rf(ctx, ss)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protos.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pro.ClientSession) error); ok {
		r1 = rf(ctx, ss)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_UpdateUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserData'
type ProClient_UpdateUserData_Call struct {
	*mock.Call
}

// UpdateUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - ss pro.ClientSession
func (_e *ProClient_Expecter) UpdateUserData(ctx interface{}, ss interface{}) *ProClient_UpdateUserData_Call {
	return &ProClient_UpdateUserData_Call{Call: _e.mock.On("UpdateUserData", ctx, ss)}
}

func (_c *ProClient_UpdateUserData_Call) Run(run func(ctx context.Context, ss pro.ClientSession)) *ProClient_UpdateUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pro.ClientSession))
	})
	return _c
}

func (_c *ProClient_UpdateUserData_Call) Return(_a0 *protos.User, _a1 error) *ProClient_UpdateUserData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_UpdateUserData_Call) RunAndReturn(run func(context.Context, pro.ClientSession) (*protos.User, error)) *ProClient_UpdateUserData_Call {
	_c.Call.Return(run)
	return _c
}

// UserCreate provides a mock function with given fields: ctx
func (_m *ProClient) UserCreate(ctx context.Context) (*pro.UserDataResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for UserCreate")
	}

	var r0 *pro.UserDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*pro.UserDataResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *pro.UserDataResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.UserDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_UserCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserCreate'
type ProClient_UserCreate_Call struct {
	*mock.Call
}

// UserCreate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ProClient_Expecter) UserCreate(ctx interface{}) *ProClient_UserCreate_Call {
	return &ProClient_UserCreate_Call{Call: _e.mock.On("UserCreate", ctx)}
}

func (_c *ProClient_UserCreate_Call) Run(run func(ctx context.Context)) *ProClient_UserCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProClient_UserCreate_Call) Return(_a0 *pro.UserDataResponse, _a1 error) *ProClient_UserCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_UserCreate_Call) RunAndReturn(run func(context.Context) (*pro.UserDataResponse, error)) *ProClient_UserCreate_Call {
	_c.Call.Return(run)
	return _c
}

// UserData provides a mock function with given fields: ctx
func (_m *ProClient) UserData(ctx context.Context) (*pro.UserDataResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for UserData")
	}

	var r0 *pro.UserDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*pro.UserDataResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *pro.UserDataResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.UserDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_UserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserData'
type ProClient_UserData_Call struct {
	*mock.Call
}

// UserData is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ProClient_Expecter) UserData(ctx interface{}) *ProClient_UserData_Call {
	return &ProClient_UserData_Call{Call: _e.mock.On("UserData", ctx)}
}

func (_c *ProClient_UserData_Call) Run(run func(ctx context.Context)) *ProClient_UserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProClient_UserData_Call) Return(_a0 *pro.UserDataResponse, _a1 error) *ProClient_UserData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_UserData_Call) RunAndReturn(run func(context.Context) (*pro.UserDataResponse, error)) *ProClient_UserData_Call {
	_c.Call.Return(run)
	return _c
}

// UserLinkCodeRequest provides a mock function with given fields: ctx, deviceId, email
func (_m *ProClient) UserLinkCodeRequest(ctx context.Context, deviceId string, email string) (bool, error) {
	ret := _m.Called(ctx, deviceId, email)

	if len(ret) == 0 {
		panic("no return value specified for UserLinkCodeRequest")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, deviceId, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, deviceId, email)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, deviceId, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_UserLinkCodeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserLinkCodeRequest'
type ProClient_UserLinkCodeRequest_Call struct {
	*mock.Call
}

// UserLinkCodeRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - deviceId string
//   - email string
func (_e *ProClient_Expecter) UserLinkCodeRequest(ctx interface{}, deviceId interface{}, email interface{}) *ProClient_UserLinkCodeRequest_Call {
	return &ProClient_UserLinkCodeRequest_Call{Call: _e.mock.On("UserLinkCodeRequest", ctx, deviceId, email)}
}

func (_c *ProClient_UserLinkCodeRequest_Call) Run(run func(ctx context.Context, deviceId string, email string)) *ProClient_UserLinkCodeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *ProClient_UserLinkCodeRequest_Call) Return(_a0 bool, _a1 error) *ProClient_UserLinkCodeRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_UserLinkCodeRequest_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *ProClient_UserLinkCodeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// UserLinkValidate provides a mock function with given fields: ctx, code
func (_m *ProClient) UserLinkValidate(ctx context.Context, code string) (*pro.UserRecovery, error) {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for UserLinkValidate")
	}

	var r0 *pro.UserRecovery
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*pro.UserRecovery, error)); ok {
		return rf(ctx, code)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *pro.UserRecovery); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pro.UserRecovery)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, code)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProClient_UserLinkValidate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserLinkValidate'
type ProClient_UserLinkValidate_Call struct {
	*mock.Call
}

// UserLinkValidate is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *ProClient_Expecter) UserLinkValidate(ctx interface{}, code interface{}) *ProClient_UserLinkValidate_Call {
	return &ProClient_UserLinkValidate_Call{Call: _e.mock.On("UserLinkValidate", ctx, code)}
}

func (_c *ProClient_UserLinkValidate_Call) Run(run func(ctx context.Context, code string)) *ProClient_UserLinkValidate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ProClient_UserLinkValidate_Call) Return(_a0 *pro.UserRecovery, _a1 error) *ProClient_UserLinkValidate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProClient_UserLinkValidate_Call) RunAndReturn(run func(context.Context, string) (*pro.UserRecovery, error)) *ProClient_UserLinkValidate_Call {
	_c.Call.Return(run)
	return _c
}

// NewProClient creates a new instance of ProClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProClient {
	mock := &ProClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
