// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field
// ignore_for_file: unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to `liblantern.h`.
class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Char> isUserFirstTime() {
    return _isUserFirstTime();
  }

  late final _isUserFirstTimePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'isUserFirstTime');
  late final _isUserFirstTime =
      _isUserFirstTimePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setFirstTimeVisit() {
    return _setFirstTimeVisit();
  }

  late final _setFirstTimeVisitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('setFirstTimeVisit');
  late final _setFirstTimeVisit =
      _setFirstTimeVisitPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Char> isUserLoggedIn() {
    return _isUserLoggedIn();
  }

  late final _isUserLoggedInPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'isUserLoggedIn');
  late final _isUserLoggedIn =
      _isUserLoggedInPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> signup(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _signup(
      email,
      password,
    );
  }

  late final _signupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('signup');
  late final _signup = _signupPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> login(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _login(
      email,
      password,
    );
  }

  late final _loginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('login');
  late final _login = _loginPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> logout() {
    return _logout();
  }

  late final _logoutPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('logout');
  late final _logout =
      _logoutPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Send recovery code to user email
  ffi.Pointer<ffi.Char> startRecoveryByEmail(
    ffi.Pointer<ffi.Char> email,
  ) {
    return _startRecoveryByEmail(
      email,
    );
  }

  late final _startRecoveryByEmailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('startRecoveryByEmail');
  late final _startRecoveryByEmail = _startRecoveryByEmailPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Complete recovery by email
  ffi.Pointer<ffi.Char> completeRecoveryByEmail(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> code,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _completeRecoveryByEmail(
      email,
      code,
      password,
    );
  }

  late final _completeRecoveryByEmailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('completeRecoveryByEmail');
  late final _completeRecoveryByEmail = _completeRecoveryByEmailPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// // This will validate code send by server
  ffi.Pointer<ffi.Char> validateRecoveryByEmail(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> code,
  ) {
    return _validateRecoveryByEmail(
      email,
      code,
    );
  }

  late final _validateRecoveryByEmailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('validateRecoveryByEmail');
  late final _validateRecoveryByEmail = _validateRecoveryByEmailPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// This will delete user accoutn and creates new user
  ffi.Pointer<ffi.Char> deleteAccount(
    ffi.Pointer<ffi.Char> password,
  ) {
    return _deleteAccount(
      password,
    );
  }

  late final _deleteAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('deleteAccount');
  late final _deleteAccount = _deleteAccountPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void setup() {
    return _setup();
  }

  late final _setupPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('setup');
  late final _setup = _setupPtr.asFunction<void Function()>();

  void sysProxyOff() {
    return _sysProxyOff();
  }

  late final _sysProxyOffPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sysProxyOff');
  late final _sysProxyOff = _sysProxyOffPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Char> sysProxyOn() {
    return _sysProxyOn();
  }

  late final _sysProxyOnPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'sysProxyOn');
  late final _sysProxyOn =
      _sysProxyOnPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> websocketAddr() {
    return _websocketAddr();
  }

  late final _websocketAddrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'websocketAddr');
  late final _websocketAddr =
      _websocketAddrPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setProxyAll(
    ffi.Pointer<ffi.Char> value,
  ) {
    return _setProxyAll(
      value,
    );
  }

  late final _setProxyAllPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setProxyAll');
  late final _setProxyAll =
      _setProxyAllPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// this method is reposible for checking if the user has updated plan or bought plans
  ffi.Pointer<ffi.Char> hasPlanUpdatedOrBuy() {
    return _hasPlanUpdatedOrBuy();
  }

  late final _hasPlanUpdatedOrBuyPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'hasPlanUpdatedOrBuy');
  late final _hasPlanUpdatedOrBuy =
      _hasPlanUpdatedOrBuyPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> applyRef(
    ffi.Pointer<ffi.Char> referralCode,
  ) {
    return _applyRef(
      referralCode,
    );
  }

  late final _applyRefPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('applyRef');
  late final _applyRef = _applyRefPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> approveDevice(
    ffi.Pointer<ffi.Char> code,
  ) {
    return _approveDevice(
      code,
    );
  }

  late final _approveDevicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('approveDevice');
  late final _approveDevice = _approveDevicePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> userLinkCode(
    ffi.Pointer<ffi.Char> email,
  ) {
    return _userLinkCode(
      email,
    );
  }

  late final _userLinkCodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('userLinkCode');
  late final _userLinkCode = _userLinkCodePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> removeDevice(
    ffi.Pointer<ffi.Char> deviceId,
  ) {
    return _removeDevice(
      deviceId,
    );
  }

  late final _removeDevicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('removeDevice');
  late final _removeDevice = _removeDevicePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> userLinkValidate(
    ffi.Pointer<ffi.Char> code,
  ) {
    return _userLinkValidate(
      code,
    );
  }

  late final _userLinkValidatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('userLinkValidate');
  late final _userLinkValidate = _userLinkValidatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> expiryDate() {
    return _expiryDate();
  }

  late final _expiryDatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'expiryDate');
  late final _expiryDate =
      _expiryDatePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> userData() {
    return _userData();
  }

  late final _userDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('userData');
  late final _userData =
      _userDataPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> emailExists(
    ffi.Pointer<ffi.Char> email,
  ) {
    return _emailExists(
      email,
    );
  }

  late final _emailExistsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('emailExists');
  late final _emailExists = _emailExistsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> testProviderRequest(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> paymentProvider,
    ffi.Pointer<ffi.Char> plan,
  ) {
    return _testProviderRequest(
      email,
      paymentProvider,
      plan,
    );
  }

  late final _testProviderRequestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('testProviderRequest');
  late final _testProviderRequest = _testProviderRequestPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// The function returns two C strings: the first represents success, and the second represents an error.
  /// If the redemption is successful, the first string contains "true", and the second string is nil.
  /// If an error occurs during redemption, the first string is nil, and the second string contains the error message.
  ffi.Pointer<ffi.Char> redeemResellerCode(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> currency,
    ffi.Pointer<ffi.Char> deviceName,
    ffi.Pointer<ffi.Char> resellerCode,
  ) {
    return _redeemResellerCode(
      email,
      currency,
      deviceName,
      resellerCode,
    );
  }

  late final _redeemResellerCodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('redeemResellerCode');
  late final _redeemResellerCode = _redeemResellerCodePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> lang() {
    return _lang();
  }

  late final _langPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('lang');
  late final _lang = _langPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setSelectLang(
    ffi.Pointer<ffi.Char> lang,
  ) {
    return _setSelectLang(
      lang,
    );
  }

  late final _setSelectLangPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setSelectLang');
  late final _setSelectLang =
      _setSelectLangPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> proUser() {
    return _proUser();
  }

  late final _proUserPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('proUser');
  late final _proUser =
      _proUserPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> deviceLinkingCode() {
    return _deviceLinkingCode();
  }

  late final _deviceLinkingCodePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'deviceLinkingCode');
  late final _deviceLinkingCode =
      _deviceLinkingCodePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> paymentRedirect(
    ffi.Pointer<ffi.Char> planID,
    ffi.Pointer<ffi.Char> currency,
    ffi.Pointer<ffi.Char> provider,
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> deviceName,
  ) {
    return _paymentRedirect(
      planID,
      currency,
      provider,
      email,
      deviceName,
    );
  }

  late final _paymentRedirectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('paymentRedirect');
  late final _paymentRedirect = _paymentRedirectPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  void exitApp() {
    return _exitApp();
  }

  late final _exitAppPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('exitApp');
  late final _exitApp = _exitAppPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Char> collectLogs(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _collectLogs(
      path,
    );
  }

  late final _collectLogsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('collectLogs');
  late final _collectLogs = _collectLogsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> reportIssue(
    ffi.Pointer<ffi.Char> email,
    ffi.Pointer<ffi.Char> issueType,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _reportIssue(
      email,
      issueType,
      description,
    );
  }

  late final _reportIssuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('reportIssue');
  late final _reportIssue = _reportIssuePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> updatePaymentMethod() {
    return _updatePaymentMethod();
  }

  late final _updatePaymentMethodPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'updatePaymentMethod');
  late final _updatePaymentMethod =
      _updatePaymentMethodPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> checkUpdates() {
    return _checkUpdates();
  }

  late final _checkUpdatesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'checkUpdates');
  late final _checkUpdates =
      _checkUpdatesPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();
}

typedef ptrdiff_t = ffi.Long;
typedef Dartptrdiff_t = int;

/// Type whose alignment is supported in every context and is at least
/// as great as that of any standard type not using alignment
/// specifiers.
final class max_align_t extends ffi.Opaque {}

final class _GoString_ extends ffi.Struct {
  external ffi.Pointer<ffi.Char> p;

  @ptrdiff_t()
  external int n;
}

typedef GoInt8 = ffi.SignedChar;
typedef DartGoInt8 = int;
typedef GoUint8 = ffi.UnsignedChar;
typedef DartGoUint8 = int;
typedef GoInt16 = ffi.Short;
typedef DartGoInt16 = int;
typedef GoUint16 = ffi.UnsignedShort;
typedef DartGoUint16 = int;
typedef GoInt32 = ffi.Int;
typedef DartGoInt32 = int;
typedef GoUint32 = ffi.UnsignedInt;
typedef DartGoUint32 = int;
typedef GoInt64 = ffi.LongLong;
typedef DartGoInt64 = int;
typedef GoUint64 = ffi.UnsignedLongLong;
typedef DartGoUint64 = int;
typedef GoInt = GoInt64;
typedef GoUint = GoUint64;
typedef GoUintptr = ffi.Size;
typedef DartGoUintptr = int;
typedef GoFloat32 = ffi.Float;
typedef DartGoFloat32 = double;
typedef GoFloat64 = ffi.Double;
typedef DartGoFloat64 = double;
typedef GoString = _GoString_;
typedef GoMap = ffi.Pointer<ffi.Void>;
typedef GoChan = ffi.Pointer<ffi.Void>;

final class GoInterface extends ffi.Struct {
  external ffi.Pointer<ffi.Void> t;

  external ffi.Pointer<ffi.Void> v;
}

final class GoSlice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @GoInt()
  external int len;

  @GoInt()
  external int cap;
}

const int NULL = 0;
